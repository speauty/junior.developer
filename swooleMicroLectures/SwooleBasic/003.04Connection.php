<?php
/**
 * Author:  Speauty
 * Email:   speauty@163.com
 * File:    007Connection.php
 * Created: 2019/11/26 下午10:40
 */

/**
 * Linux下的Socket编程
 * 网络上的两个程序通过一个双向的通信连接实现数据的交换, 连接的一端称为一个socket.
 * Socket是TCP/IP协议族通信的中间软件抽象层, 一组接口.
 */

/**
 * syscall是x86-64架构上进入内核模式的默认方式
 * int 0x80 是一种比较旧的进入内核模式的方式
 */

/**
 * 时间片 又称为量子或处理器片, 是分时操作系统分配给每个正在运行的进程微观上的一段CPU时间(在抢占内核中是: 从进程开始运行直到被抢占的时间)
 * 一台计算机如果只有一个CPU, 是不可能真正地同时运行多个任务的. 这些进程"看起来像"同时运行, 实则是轮番运行,
 * 由于时间片通常很短(在linux上为5ms~800ms), 用户不会感觉到.
 */

/**
 * 操作系统调度线程时, 会挂起当前执行线程, 同时保存它寄存器中的信息, 接着查看线程列表决定下一个线程的运行,
 * 从内存中恢复其寄存器信息和现场并开始执行. 不同线程之间存在上下文切换, 这包括保存一个用户线程的状态到内存, 恢复另一个线程的信息到寄存器,
 * 同时还要更新sheduler相关的数据结构.
 */

/**
 * 常见的检查连接的方法
 * 1. 检查连接属性: Connected属性, isConnect()方法; 在协程中, 这个方法基本无效
 * 2. ping
 * 3. recv(PEEK)
 *
 * 最稳健的方法: 不主动检查连接状态, 及时进行错误处理
 */